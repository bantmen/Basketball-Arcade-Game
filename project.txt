module project (HEX0, HEX1, HEX4, HEX5, LEDR, CLOCK_50, GPIO_0, SW);
	output [6:0] HEX0, HEX1, HEX4, HEX5;
	output [1:0] LEDR;
	input [1:0] SW; 
	input [0:0] GPIO_0;
	input CLOCK_50;
	
	reg [5:0] GOAL;
	reg [5:0] LAST_GOAL_AT;
	wire [5:0] TIMER;
	wire [3:0] MSD_t, LSD_t, MSD_g, LSD,g;
	
	assign LEDR = SW;
	
	initial GOAL = 0;
	
	counter C0 (TIMER, CLOCK_50, SW[0], SW[1]);
	
	always @ (negedge SW[1], posedge CLOCK_50, negedge GPIO_0)
		if (~SW[1])
			GOAL <= 0;
		else if (~GPIO_0 && CLOCK_50) begin
			if (TIMER != 0) begin
				GOAL <= GOAL + 1;
				LAST_GOAL_AT <= TIMER;
			end
		end
	
	bcd_decoder T0 (MSD_t, LSD_t, TIMER);
	bcd_decoder T1 (MSD_g, LSD_g, GOAL);
	
	seg_display S0 (HEX0, LSD_t);
	seg_display S1 (HEX1, MSD_t);
	seg_display S2 (HEX4, LSD_g);
	seg_display S3 (HEX5, MSD_g);

endmodule

module counter (Q, Clk, SW, Clr);
	output reg [5:0] Q;
	input Clk, SW, Clr;
	
	reg [25:0] i;
	
	initial begin
		Q = 6'd60;
		i = 0;
	end
	
	always @ (negedge Clr, posedge Clk)
		if (~Clr) begin
			Q <= 6'd60;
			i <= 0;
		end
		else if (i == 26'd50000000) begin
			if (SW && (Q != 0)) begin
				Q <= Q - 1;
				i <= 0;
			end
		end
		else 
			i <= i + 1;

endmodule
			
	
module bcd_decoder (MSD, LSD, I);
	output reg [3:0] MSD, LSD;
	input [5:0] I;

	always @ (I) begin
		if (I == 6'd60) begin
			MSD <= 4'd6;
			LSD <= 0;
		end 
		else if (I >= 6'd50) begin
			MSD <= 4'd5;
			LSD <= I - 6'd50;
		end
		else if (I >= 6'd40) begin
			MSD <= 4'd4;
			LSD <= I - 6'd40;
		end
		else if (I >= 6'd30) begin
			MSD <= 4'd3;
			LSD <= I - 6'd30;
		end
		else if (I >= 6'd20) begin
			MSD <= 4'd2;
			LSD <= I - 6'd20;
		end
		else if (I >= 6'd10) begin
			MSD <= 1;
			LSD <= I - 6'd10;
		end
		else begin
			MSD <= 0;
			LSD <= I;		
		end
	end

endmodule  

module seg_display (s_s, S);
  input [3:0] S;
  output [6:0] s_s;

	assign s_s[0] = ((~S[3]&~S[2]&~S[1]&S[0]) | (~S[3]&S[2]&~S[1]&~S[0]) 
						| (S[3]&~S[2]&S[1]&S[0]) | (S[3]&S[2]&~S[1]&S[0]));
	assign s_s[1] = ((~S[3]&S[2]&~S[1]&S[0]) | (~S[3]&S[2]&S[1]&~S[0]) 
						| (S[3]&~S[2]&S[1]&S[0]) | (S[3]&S[2]&~S[1]&~S[0]) 
						| (S[3]&S[2]&S[1]&~S[0]) | (S[3]&S[2]&S[1]&S[0]));
	assign s_s[2] = ((~S[3]&~S[2]&S[1]&~S[0]) | (S[3]&S[2]&~S[1]&~S[0]) 
						| (S[3]&S[2]&S[1]&~S[0]) | (S[3]&S[2]&S[1]&S[0]));
	assign s_s[3] = ((~S[3]&~S[2]&~S[1]&S[0]) | (~S[3]&S[2]&~S[1]&~S[0]) 
						| (~S[3]&S[2]&S[1]&S[0]) | (S[3]&~S[2]&S[1]&~S[0]) 
						| (S[3]&S[2]&S[1]&S[0]));
	assign s_s[4] = ((~S[3]&~S[2]&~S[1]&S[0]) | (~S[3]&~S[2]&S[1]&S[0]) 
						| (~S[3]&S[2]&~S[1]&~S[0]) | (~S[3]&S[2]&~S[1]&S[0]) 
						| (~S[3]&S[2]&S[1]&S[0]) | (S[3]&~S[2]&~S[1]&S[0]));
	assign s_s[5] = ((~S[3]&~S[2]&~S[1]&S[0]) | (~S[3]&~S[2]&S[1]&~S[0]) 
						| (~S[3]&~S[2]&S[1]&S[0]) | (~S[3]&S[2]&S[1]&S[0]) 
						| (S[3]&S[2]&~S[1]&S[0]));
	assign s_s[6] = ((~S[3]&~S[2]&~S[1]&~S[0]) | (~S[3]&~S[2]&~S[1]&S[0]) 
						| (~S[3]&S[2]&S[1]&S[0]) | (S[3]&S[2]&~S[1]&~S[0]));
						
endmodule 